# 計算複雑性理論の実装
## オートマトンの実装
### 10月27日

- 数学的な理論としては正常系しかないが、工学的観点では実装時に準正常系の動作も考慮する必要がある
- チューリングマシンにせよオートマトンにせよ「状態」と「遷移」が本質的。こういう本質がソースコードに落とすと見えてくるのが実装の面白いところ
- アルファベットや状態遷移関数を数学的に厳密な実装が必ずしもソースコードの品質を高めることにはつながらない。無駄に煩雑になる場合もある
- 例えば各状態が受け取る文字列は実際にはJavaではChar型であるが、Char型を新しくAlphabet型として定義しなおすことには実質的には意味がない
- 状態遷移関数のとしてAlphabetを定義してもそれを参照する必要性はうすく、用途は型チェックくらいにしか使えない
- Stateクラスに状態変異メソッドをもたせようかと思ったけど、そうするとDFA/NFA/Turingマシン毎に実装に差分が生じる
- Stateを抽象クラス/インタフェースにするかクラスを完全に分離するのかのどちらか
- StateSetを単にエイリアス目的でHashSetの継承にした。Java的にはあまりお行儀がよくないらしい...

### 10月28日
- ようやく基本的な実装方針がきまった
- DFAとNFAのたった2種類なのに継承を用いて丁寧に実装しようとすると意外に難しい
- 簡単な設計でさえもデザインパターンの基本的な知識がないとできないのな
- NFAで並列遷移を実装する場合、状態に文字列を埋め込む場合ははコピーを生成しないと同一状態だと衝突する
- 文字列は状態のメンバとしてもたせることにする
- つまるところ状態遷移図を実装できればよい
- そのため最初に各状態のインスタンスを生成する
- 各状態には自分の遷移関数を保持する
- 各状態には現在の文字列を保持する
- 遷移関数はDFAでは状態を返すがNFAでは現在の状態のコピーを返す
- 状態は遷移関数と現在の文字列を参照して別状態に遷移する
- デザインパターンはBridgeパターンを採用する
- オブジェクト指向のメリットの1つは呼び出し側がサブクラス内部の実装を意識せずにすむこと

## 10月29日
- 以前よりもDFAの可読性が大幅に向上した。本質を見極めてコーディングすると全然違う！

## 11月1日
- 検査例外を追加した。純粋な数学のモデルとしては例外はありえないのだけどJavaの勉強のため。